#-------------------------------------------------------------------------------
# Lawrence Livermore National Laboratory
# generate_datain.py
#-------------------------------------------------------------------------------

import os
import csv
import sys
from parse         import *
from axi_delay_pkg import *

#-------------------------------------------------------------------------------
# Global Constants
#-------------------------------------------------------------------------------
#crc           = "0000"  ## don't care field, will be replaced when packet is generated by FPGA
#swr           = "0"
#srd           = "1"
#nop           = "0"

LAST  = 0  ## defines last bit of packet
DEL   = 0  ## used within generation loop
DELZ  = 0  ## zero inter-event gap (ieg). DO NOT CHANGE!!!
DEL0  = 20
DEL1  = 20
DEL2  = 20
DEL3  = 20
DEL4  = 20
DEL5  = 20

#-------------------------------------------------------------------------------
# default output file names
#-------------------------------------------------------------------------------
op_dir               = ""        ## not used
opfile_name          = "axi_event.in"

#-------------------------------------------------------------------------------
# Check for existience of file; delete if it exists
#-------------------------------------------------------------------------------

if os.path.exists(opfile_name):
    os.remove(opfile_name)
      
#-------------------------------------------------------------------------------
# Send packet events:
# opfile_name, ipg(8), s_axi_id[15:0], s_axi_addr(39:0), s_axi_data[63:0], s_axi_strb[15:0], s_axi_len[7:0], 
#                      s_axi_size[2:0], s_axi_burst[1:0], s_axi_lock[1:0], s_axi_cache[3:0],
#                      s_axi_prot[2:0], s_axi_qos[3:0], s_axi_region[3:0], s_axi_valid, s_axi_last, s_axi_resp
#
# Some field definitions (along with the widths for THIS IMPLEMENTATION): 
#  s_axi_len[7:0]  = burst length, where "actual burst length" =  s_axi_len + 1
#  s_axi_size[2:0] = bytes per transfer, encoded as follows:
#                    0b000 = 1 byte
#                    0b001 = 2 bytes
#                    0b010 = 4 bytes
#                    0b011 = 8 bytes
#                    0b100 = 16 bytes
#                    0b101 = 32 bytes
#                    0b110 = 64 bytes
#                    0b111 = 128 bytes
#  s_axi_burst[1:0]   = 0b00 = FIXED
#                       0b01 = INCR
#                       0b10 = WRAP
#                       0b11 = Reserved
#  s_axi_lock[1:0]    = 0b00 = Normal Access
#                       0b01 = Exclusive Access
#                       0b10 = Locked Access
#                       0b11 = Reserved
#  s_axi_prot[2:0]    = [0] = 1: privileged access, 0: unprivileged access
#                       [1] = 1: non-secure access, 0: secure access
#                       [2] = 1: instruction access, 0: data access
# s_axi_addr[39:0] => Hex address. HOWEVER, when s_axi_addr = 0xFFFFFFFFFF, axi_master treats this as a dummy cycle for the purpose of delaying the first event
#-------------------------------------------------------------------------------
##                  ieg  resp  id      addr          data                                strb    len   size   burst lock  cache   prot   qos     region  valid last
##parse(opfile_name, 50, 0b00, 0x0001, 0xFFFFFFFFFF, 0x123456789abcdef0123456789abcdef0, 0xffff, 0x04, 0b110, 0b01, 0b00, 0b0010, 0b010, 0b0000, 0b0001, 0b1,  0b1) ##Dummy cycle

NUM_LOOPS       = 128
BEATS_PER_BURST = 4
AXI_ID_0        = 0x0000
AXI_ID_1        = 0x0001
AXI_ID_2        = 0x0002
AXI_ID_3        = 0x0003
AXI_ID_4        = 0x0004
AXI_ID_5        = 0x0005

for x in range (NUM_LOOPS):
    for y in range (BEATS_PER_BURST):
        if (y == BEATS_PER_BURST-1):
            DEL  = DEL0
            LAST = 1
        else:
            DEL  = DELZ
            LAST = 0
        parse(opfile_name, DEL, 0b00, AXI_ID_0, x, y, 0xffff, 0x04, 0b110, 0b01, 0b00, 0b0010, 0b010, 0b0000, 0b0001, 0b1, LAST)

    for y in range (BEATS_PER_BURST):
        if (y == BEATS_PER_BURST-1):
            DEL  = DEL1
            LAST = 1
        else:
            DEL  = DELZ
            LAST = 0
        parse(opfile_name, DEL, 0b00, AXI_ID_1, x, y, 0xffff, 0x04, 0b110, 0b01, 0b00, 0b0010, 0b010, 0b0000, 0b0001, 0b1, LAST)

    for y in range (BEATS_PER_BURST):
        if (y == BEATS_PER_BURST-1):
            DEL  = DEL2
            LAST = 1
        else:
            DEL  = DELZ
            LAST = 0
        parse(opfile_name, DEL, 0b00, AXI_ID_2, x, y, 0xffff, 0x04, 0b110, 0b01, 0b00, 0b0010, 0b010, 0b0000, 0b0001, 0b1, LAST)

    for y in range (BEATS_PER_BURST):
        if (y == BEATS_PER_BURST-1):
            DEL  = DEL3
            LAST = 1
        else:
            DEL  = DELZ
            LAST = 0
        parse(opfile_name, DEL, 0b00, AXI_ID_3, x, y, 0xffff, 0x04, 0b110, 0b01, 0b00, 0b0010, 0b010, 0b0000, 0b0001, 0b1, LAST)

    for y in range (BEATS_PER_BURST):
        if (y == BEATS_PER_BURST-1):
            DEL  = DEL4
            LAST = 1
        else:
            DEL  = DELZ
            LAST = 0
        parse(opfile_name, DEL, 0b00, AXI_ID_4, x, y, 0xffff, 0x04, 0b110, 0b01, 0b00, 0b0010, 0b010, 0b0000, 0b0001, 0b1, LAST)

    for y in range (BEATS_PER_BURST):
        if (y == BEATS_PER_BURST-1):
            DEL  = DEL5
            LAST = 1
        else:
            DEL  = DELZ
            LAST = 0
        parse(opfile_name, DEL, 0b00, AXI_ID_5, x, y, 0xffff, 0x04, 0b110, 0b01, 0b00, 0b0010, 0b010, 0b0000, 0b0001, 0b1, LAST)

